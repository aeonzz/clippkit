{
  "name": "u-bar-waveform",
  "type": "registry:block",
  "description": "",
  "files": [
    {
      "path": "blocks/bar-waveform/page.tsx",
      "content": "\"use client\";\r\n\r\nimport React from \"react\";\r\nimport { MediaUtilsAudioData, useAudioData } from \"@remotion/media-utils\";\r\nimport { Player } from \"@remotion/player\";\r\nimport { Audio } from \"remotion\";\r\n\r\nimport BarWaveform from \"@/registry/default/components/bar-waveform\"; // Adjust path as necessary\r\n\r\nconst MEDIA_SRC =\r\n  \"https://rwxrdxvxndclnqvznxfj.supabase.co/storage/v1/object/public/sounds//moon-landing.mp3\";\r\n\r\ninterface AudioWaveformCompositionProps {\r\n  barWaveformProps: Omit<\r\n    React.ComponentProps<typeof BarWaveform>,\r\n    \"audioData\"\r\n  > & { audioData?: MediaUtilsAudioData | null };\r\n  mediaSrc: string;\r\n}\r\n\r\nconst AudioWaveformComposition: React.FC<AudioWaveformCompositionProps> = ({\r\n  barWaveformProps,\r\n  mediaSrc,\r\n}) => {\r\n  return (\r\n    <>\r\n      <BarWaveform {...barWaveformProps} />\r\n      <Audio src={mediaSrc} />\r\n    </>\r\n  );\r\n};\r\n\r\nexport default function BarWaveformDemo() {\r\n  const audioData = useAudioData(MEDIA_SRC);\r\n\r\n  const barWaveformProps = React.useMemo(\r\n    () => ({\r\n      numberOfSamples: 50,\r\n      barColor: \"var(--foreground)\",\r\n      barWidth: 3,\r\n      barGap: 2,\r\n      waveAmplitude: 220,\r\n      waveSpeed: 5,\r\n      audioData,\r\n      barBorderRadius: 0,\r\n      growUpwardsOnly: false,\r\n    }),\r\n    [audioData]\r\n  );\r\n\r\n  const playerDurationInFrames = audioData\r\n    ? Math.floor(audioData.durationInSeconds * 30)\r\n    : 300;\r\n\r\n  return (\r\n    <div className=\"aspect-video h-[180px] sm:h-[350px] md:h-[400px]\">\r\n      <Player\r\n        component={AudioWaveformComposition}\r\n        inputProps={{ barWaveformProps, mediaSrc: MEDIA_SRC }}\r\n        durationInFrames={playerDurationInFrames}\r\n        compositionWidth={640}\r\n        compositionHeight={360}\r\n        fps={30}\r\n        style={{\r\n          width: \"100%\",\r\n          height: \"100%\",\r\n          backgroundColor: \"transparent\",\r\n        }}\r\n        controls\r\n        loop\r\n      />\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:page",
      "target": "app/main.tsx"
    },
    {
      "path": "components/bar-waveform.tsx",
      "content": "\"use client\";\n\nimport React, { useEffect, useState } from \"react\";\nimport {\n  MediaUtilsAudioData,\n  visualizeAudioWaveform,\n} from \"@remotion/media-utils\";\nimport { useCurrentFrame, useVideoConfig } from \"remotion\";\n\n// Helper function to generate waveform samples\nconst generateWaveformSamples = (\n  audioData: MediaUtilsAudioData | null | undefined,\n  numberOfSamples: number,\n  frame: number,\n  waveSpeed: number,\n  fps: number\n): number[] => {\n  if (audioData) {\n    // For bar waveform, we might want to adjust how windowInSeconds or smoothing works\n    // For now, using a similar approach to linear waveform\n    return visualizeAudioWaveform({\n      fps,\n      frame,\n      audioData,\n      numberOfSamples,\n      windowInSeconds: 1 / fps, // Visualize a single frame's worth of audio\n    });\n  }\n  // Fallback for when audioData is not available - simple sine wave\n  return Array(numberOfSamples)\n    .fill(0)\n    .map((_, i) => {\n      return (\n        Math.sin(frame / waveSpeed + (i / numberOfSamples) * 2 * Math.PI) *\n          0.5 +\n        0.5\n      );\n    });\n};\n\ninterface BarWaveformProps {\n  audioData?: MediaUtilsAudioData | null;\n  numberOfSamples?: number;\n  barColor?: string;\n  barWidth?: number; // Width of each bar\n  barGap?: number; // Gap between bars\n  waveAmplitude?: number; // Max height of the bars\n  waveSpeed?: number;\n  containerStyle?: React.CSSProperties;\n  height?: string | number;\n  width?: string | number;\n  barBorderRadius?: string | number;\n  growUpwardsOnly?: boolean; // New prop: if true, bars only grow upwards from the center\n}\n\nexport default function BarWaveform({\n  audioData,\n  numberOfSamples = 64,\n  barColor = \"var(--foreground)\",\n  barWidth = 5,\n  barGap = 2,\n  waveAmplitude = 100,\n  waveSpeed = 10,\n  containerStyle,\n  height: propHeight,\n  width: propWidth,\n  barBorderRadius = 0,\n  growUpwardsOnly = false, // Default value for the new prop\n}: BarWaveformProps) {\n  const frame = useCurrentFrame();\n  const { width: videoWidth, height: videoHeight, fps } = useVideoConfig();\n\n  const finalWidth = typeof propWidth === \"number\" ? propWidth : videoWidth;\n  const finalHeight = typeof propHeight === \"number\" ? propHeight : videoHeight;\n\n  const [barHeights, setBarHeights] = useState<number[]>([]);\n\n  useEffect(() => {\n    const waveformData = generateWaveformSamples(\n      audioData,\n      numberOfSamples,\n      frame,\n      waveSpeed,\n      fps\n    );\n\n    // Map waveform data (0 to 1) to bar heights\n    const newBarHeights = waveformData.map((sample) =>\n      // Ensure minimum height for visibility, scale by waveAmplitude and center\n      Math.max(1, sample * waveAmplitude)\n    );\n    setBarHeights(newBarHeights);\n  }, [frame, audioData, numberOfSamples, waveAmplitude, waveSpeed, fps]);\n\n  // Calculate total width occupied by bars and gaps to center them if needed\n  const totalBarWidth = numberOfSamples * barWidth;\n  const totalGapWidth = (numberOfSamples - 1) * barGap;\n  const waveformVisualWidth = totalBarWidth + totalGapWidth;\n  const startX = (finalWidth - waveformVisualWidth) / 2;\n\n  return (\n    <div\n      style={{\n        width: finalWidth,\n        height: finalHeight,\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\", // Or use startX for precise positioning\n        overflow: \"hidden\",\n        backgroundColor: \"transparent\",\n        ...containerStyle,\n      }}\n    >\n      <svg\n        viewBox={`0 0 ${finalWidth} ${finalHeight}`}\n        width={finalWidth}\n        height={finalHeight}\n        style={{\n          width: finalWidth,\n          height: finalHeight,\n        }}\n      >\n        {barHeights.map((barH, i) => {\n          const x = startX + i * (barWidth + barGap);\n          // Bars drawn from center, extending up and down\n          // For simplicity, drawing upwards from baseline for now\n          let rectY: number;\n          let rectHeightValue: number;\n\n          if (growUpwardsOnly) {\n            // Bar grows upwards from the center line\n            const upwardHeight = barH / 2; // Height from the center line\n            rectY = finalHeight / 2 - upwardHeight;\n            // Height of the bar is upwardHeight, capped by the available space above the center line (finalHeight / 2)\n            // Also ensure a minimum height of 1 for visibility if upwardHeight is very small but not zero\n            rectHeightValue =\n              upwardHeight > 0\n                ? Math.max(1, Math.min(upwardHeight, finalHeight / 2))\n                : 0;\n          } else {\n            // Original behavior: bar is centered vertically\n            rectY = finalHeight / 2 - barH / 2;\n            // Ensure a minimum height of 1 for visibility if barH is very small but not zero\n            rectHeightValue =\n              barH > 0 ? Math.max(1, Math.min(barH, finalHeight)) : 0;\n          }\n\n          return (\n            <rect\n              key={i}\n              x={x}\n              y={rectY}\n              width={barWidth}\n              height={rectHeightValue}\n              fill={barColor}\n              rx={barBorderRadius} // For rounded corners\n              ry={barBorderRadius} // For rounded corners\n            />\n          );\n        })}\n      </svg>\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": ""
    }
  ],
  "meta": {
    "iframeHeight": "600px",
    "container": "w-full bg-surface min-h-svh flex px-6 py-12 items-center md:pt-20 justify-center min-w-0 xl:py-24",
    "mobile": "component"
  }
}