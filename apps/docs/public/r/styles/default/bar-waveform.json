{
  "name": "bar-waveform",
  "type": "registry:component",
  "dependencies": [
    "remotion",
    "@remotion/media-utils"
  ],
  "files": [
    {
      "path": "components/bar-waveform.tsx",
      "content": "\"use client\";\n\nimport React, { useEffect, useState } from \"react\";\nimport {\n  MediaUtilsAudioData,\n  visualizeAudioWaveform,\n} from \"@remotion/media-utils\";\nimport { useCurrentFrame, useVideoConfig } from \"remotion\";\n\n// Helper function to generate waveform samples\nconst generateWaveformSamples = (\n  audioData: MediaUtilsAudioData | null | undefined,\n  numberOfSamples: number,\n  frame: number,\n  waveSpeed: number,\n  fps: number\n): number[] => {\n  if (audioData) {\n    // For bar waveform, we might want to adjust how windowInSeconds or smoothing works\n    // For now, using a similar approach to linear waveform\n    return visualizeAudioWaveform({\n      fps,\n      frame,\n      audioData,\n      numberOfSamples,\n      windowInSeconds: 1 / fps, // Visualize a single frame's worth of audio\n    });\n  }\n  // Fallback for when audioData is not available - simple sine wave\n  return Array(numberOfSamples)\n    .fill(0)\n    .map((_, i) => {\n      return (\n        Math.sin(frame / waveSpeed + (i / numberOfSamples) * 2 * Math.PI) *\n          0.5 +\n        0.5\n      );\n    });\n};\n\ninterface BarWaveformProps {\n  audioData?: MediaUtilsAudioData | null;\n  numberOfSamples?: number;\n  barColor?: string;\n  barWidth?: number; // Width of each bar\n  barGap?: number; // Gap between bars\n  waveAmplitude?: number; // Max height of the bars\n  waveSpeed?: number;\n  containerStyle?: React.CSSProperties;\n  height?: string | number;\n  width?: string | number;\n  barBorderRadius?: string | number;\n  growUpwardsOnly?: boolean; // New prop: if true, bars only grow upwards from the center\n}\n\nexport default function BarWaveform({\n  audioData,\n  numberOfSamples = 64,\n  barColor = \"var(--foreground)\",\n  barWidth = 5,\n  barGap = 2,\n  waveAmplitude = 100,\n  waveSpeed = 10,\n  containerStyle,\n  height: propHeight,\n  width: propWidth,\n  barBorderRadius = 0,\n  growUpwardsOnly = false, // Default value for the new prop\n}: BarWaveformProps) {\n  const frame = useCurrentFrame();\n  const { width: videoWidth, height: videoHeight, fps } = useVideoConfig();\n\n  const finalWidth = typeof propWidth === \"number\" ? propWidth : videoWidth;\n  const finalHeight = typeof propHeight === \"number\" ? propHeight : videoHeight;\n\n  const [barHeights, setBarHeights] = useState<number[]>([]);\n\n  useEffect(() => {\n    const waveformData = generateWaveformSamples(\n      audioData,\n      numberOfSamples,\n      frame,\n      waveSpeed,\n      fps\n    );\n\n    // Map waveform data (0 to 1) to bar heights\n    const newBarHeights = waveformData.map((sample) =>\n      // Ensure minimum height for visibility, scale by waveAmplitude and center\n      Math.max(1, sample * waveAmplitude)\n    );\n    setBarHeights(newBarHeights);\n  }, [frame, audioData, numberOfSamples, waveAmplitude, waveSpeed, fps]);\n\n  // Calculate total width occupied by bars and gaps to center them if needed\n  const totalBarWidth = numberOfSamples * barWidth;\n  const totalGapWidth = (numberOfSamples - 1) * barGap;\n  const waveformVisualWidth = totalBarWidth + totalGapWidth;\n  const startX = (finalWidth - waveformVisualWidth) / 2;\n\n  return (\n    <div\n      style={{\n        width: finalWidth,\n        height: finalHeight,\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\", // Or use startX for precise positioning\n        overflow: \"hidden\",\n        backgroundColor: \"transparent\",\n        ...containerStyle,\n      }}\n    >\n      <svg\n        viewBox={`0 0 ${finalWidth} ${finalHeight}`}\n        width={finalWidth}\n        height={finalHeight}\n        style={{\n          width: finalWidth,\n          height: finalHeight,\n        }}\n      >\n        {barHeights.map((barH, i) => {\n          const x = startX + i * (barWidth + barGap);\n          // Bars drawn from center, extending up and down\n          // For simplicity, drawing upwards from baseline for now\n          let rectY: number;\n          let rectHeightValue: number;\n\n          if (growUpwardsOnly) {\n            // Bar grows upwards from the center line\n            const upwardHeight = barH / 2; // Height from the center line\n            rectY = finalHeight / 2 - upwardHeight;\n            // Height of the bar is upwardHeight, capped by the available space above the center line (finalHeight / 2)\n            // Also ensure a minimum height of 1 for visibility if upwardHeight is very small but not zero\n            rectHeightValue =\n              upwardHeight > 0\n                ? Math.max(1, Math.min(upwardHeight, finalHeight / 2))\n                : 0;\n          } else {\n            // Original behavior: bar is centered vertically\n            rectY = finalHeight / 2 - barH / 2;\n            // Ensure a minimum height of 1 for visibility if barH is very small but not zero\n            rectHeightValue =\n              barH > 0 ? Math.max(1, Math.min(barH, finalHeight)) : 0;\n          }\n\n          return (\n            <rect\n              key={i}\n              x={x}\n              y={rectY}\n              width={barWidth}\n              height={rectHeightValue}\n              fill={barColor}\n              rx={barBorderRadius} // For rounded corners\n              ry={barBorderRadius} // For rounded corners\n            />\n          );\n        })}\n      </svg>\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": ""
    }
  ]
}