{
  "name": "bar-waveform",
  "type": "registry:component",
  "dependencies": [
    "remotion",
    "@remotion/media-utils"
  ],
  "files": [
    {
      "path": "components/bar-waveform.tsx",
      "content": "\"use client\";\r\n\r\nimport React, { useEffect, useState } from \"react\";\r\nimport {\r\n  MediaUtilsAudioData,\r\n  visualizeAudioWaveform,\r\n} from \"@remotion/media-utils\";\r\nimport { useCurrentFrame, useVideoConfig } from \"remotion\";\r\n\r\n// Helper function to generate waveform samples\r\nconst generateWaveformSamples = (\r\n  audioData: MediaUtilsAudioData | null | undefined,\r\n  numberOfSamples: number,\r\n  frame: number,\r\n  waveSpeed: number,\r\n  fps: number\r\n): number[] => {\r\n  if (audioData) {\r\n    // For bar waveform, we might want to adjust how windowInSeconds or smoothing works\r\n    // For now, using a similar approach to linear waveform\r\n    return visualizeAudioWaveform({\r\n      fps,\r\n      frame,\r\n      audioData,\r\n      numberOfSamples,\r\n      windowInSeconds: 1 / fps, // Visualize a single frame's worth of audio\r\n    });\r\n  }\r\n  // Fallback for when audioData is not available - simple sine wave\r\n  return Array(numberOfSamples)\r\n    .fill(0)\r\n    .map((_, i) => {\r\n      return (\r\n        Math.sin(frame / waveSpeed + (i / numberOfSamples) * 2 * Math.PI) *\r\n          0.5 +\r\n        0.5\r\n      );\r\n    });\r\n};\r\n\r\ninterface BarWaveformProps {\r\n  audioData?: MediaUtilsAudioData | null;\r\n  numberOfSamples?: number;\r\n  barColor?: string;\r\n  barWidth?: number; // Width of each bar\r\n  barGap?: number; // Gap between bars\r\n  waveAmplitude?: number; // Max height of the bars\r\n  waveSpeed?: number;\r\n  containerStyle?: React.CSSProperties;\r\n  height?: string | number;\r\n  width?: string | number;\r\n  barBorderRadius?: string | number;\r\n  growUpwardsOnly?: boolean; // New prop: if true, bars only grow upwards from the center\r\n}\r\n\r\nexport default function BarWaveform({\r\n  audioData,\r\n  numberOfSamples = 64,\r\n  barColor = \"var(--foreground)\",\r\n  barWidth = 5,\r\n  barGap = 2,\r\n  waveAmplitude = 100,\r\n  waveSpeed = 10,\r\n  containerStyle,\r\n  height: propHeight,\r\n  width: propWidth,\r\n  barBorderRadius = 0,\r\n  growUpwardsOnly = false, // Default value for the new prop\r\n}: BarWaveformProps) {\r\n  const frame = useCurrentFrame();\r\n  const { width: videoWidth, height: videoHeight, fps } = useVideoConfig();\r\n\r\n  const finalWidth = typeof propWidth === \"number\" ? propWidth : videoWidth;\r\n  const finalHeight = typeof propHeight === \"number\" ? propHeight : videoHeight;\r\n\r\n  const [barHeights, setBarHeights] = useState<number[]>([]);\r\n\r\n  useEffect(() => {\r\n    const waveformData = generateWaveformSamples(\r\n      audioData,\r\n      numberOfSamples,\r\n      frame,\r\n      waveSpeed,\r\n      fps\r\n    );\r\n\r\n    // Map waveform data (0 to 1) to bar heights\r\n    const newBarHeights = waveformData.map((sample) =>\r\n      // Ensure minimum height for visibility, scale by waveAmplitude and center\r\n      Math.max(1, sample * waveAmplitude)\r\n    );\r\n    setBarHeights(newBarHeights);\r\n  }, [frame, audioData, numberOfSamples, waveAmplitude, waveSpeed, fps]);\r\n\r\n  // Calculate total width occupied by bars and gaps to center them if needed\r\n  const totalBarWidth = numberOfSamples * barWidth;\r\n  const totalGapWidth = (numberOfSamples - 1) * barGap;\r\n  const waveformVisualWidth = totalBarWidth + totalGapWidth;\r\n  const startX = (finalWidth - waveformVisualWidth) / 2;\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        width: finalWidth,\r\n        height: finalHeight,\r\n        display: \"flex\",\r\n        alignItems: \"center\",\r\n        justifyContent: \"center\", // Or use startX for precise positioning\r\n        overflow: \"hidden\",\r\n        backgroundColor: \"transparent\",\r\n        ...containerStyle,\r\n      }}\r\n    >\r\n      <svg\r\n        viewBox={`0 0 ${finalWidth} ${finalHeight}`}\r\n        width={finalWidth}\r\n        height={finalHeight}\r\n        style={{\r\n          width: finalWidth,\r\n          height: finalHeight,\r\n        }}\r\n      >\r\n        {barHeights.map((barH, i) => {\r\n          const x = startX + i * (barWidth + barGap);\r\n          // Bars drawn from center, extending up and down\r\n          // For simplicity, drawing upwards from baseline for now\r\n          let rectY: number;\r\n          let rectHeightValue: number;\r\n\r\n          if (growUpwardsOnly) {\r\n            // Bar grows upwards from the center line\r\n            const upwardHeight = barH / 2; // Height from the center line\r\n            rectY = finalHeight / 2 - upwardHeight;\r\n            // Height of the bar is upwardHeight, capped by the available space above the center line (finalHeight / 2)\r\n            // Also ensure a minimum height of 1 for visibility if upwardHeight is very small but not zero\r\n            rectHeightValue =\r\n              upwardHeight > 0\r\n                ? Math.max(1, Math.min(upwardHeight, finalHeight / 2))\r\n                : 0;\r\n          } else {\r\n            // Original behavior: bar is centered vertically\r\n            rectY = finalHeight / 2 - barH / 2;\r\n            // Ensure a minimum height of 1 for visibility if barH is very small but not zero\r\n            rectHeightValue =\r\n              barH > 0 ? Math.max(1, Math.min(barH, finalHeight)) : 0;\r\n          }\r\n\r\n          return (\r\n            <rect\r\n              key={i}\r\n              x={x}\r\n              y={rectY}\r\n              width={barWidth}\r\n              height={rectHeightValue}\r\n              fill={barColor}\r\n              rx={barBorderRadius} // For rounded corners\r\n              ry={barBorderRadius} // For rounded corners\r\n            />\r\n          );\r\n        })}\r\n      </svg>\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": ""
    }
  ]
}