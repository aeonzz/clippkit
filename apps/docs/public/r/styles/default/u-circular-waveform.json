{
  "name": "u-circular-waveform",
  "type": "registry:block",
  "description": "",
  "files": [
    {
      "path": "blocks/circular-waveform/page.tsx",
      "content": "\"use client\";\r\n\r\nimport React from \"react\"; // Import React\r\nimport { MediaUtilsAudioData, useAudioData } from \"@remotion/media-utils\";\r\nimport { Player } from \"@remotion/player\";\r\nimport { Audio } from \"remotion\"; // Import Audio\r\n\r\nimport CircularWaveform from \"@/registry/default/components/circular-waveform\"; // Adjust path as necessary\r\n\r\n// Media source for the demo\r\nconst MEDIA_SRC =\r\n  \"https://rwxrdxvxndclnqvznxfj.supabase.co/storage/v1/object/public/sounds//moon-landing.mp3\";\r\n\r\n// Define props for the new composition component\r\ninterface AudioCircularWaveformCompositionProps {\r\n  circularWaveformProps: Omit<\r\n    React.ComponentProps<typeof CircularWaveform>,\r\n    \"audioData\"\r\n  > & { audioData?: MediaUtilsAudioData | null };\r\n  mediaSrc: string;\r\n}\r\n\r\n// New component combining CircularWaveform and Audio\r\nconst AudioCircularWaveformComposition: React.FC<\r\n  AudioCircularWaveformCompositionProps\r\n> = ({ circularWaveformProps, mediaSrc }) => {\r\n  return (\r\n    <>\r\n      <CircularWaveform {...circularWaveformProps} />\r\n      <Audio src={mediaSrc} />\r\n    </>\r\n  );\r\n};\r\n\r\nexport default function CircularWaveformDemo() {\r\n  const audioData = useAudioData(MEDIA_SRC);\r\n\r\n  const circularWaveformProps = React.useMemo(\r\n    () => ({\r\n      barCount: 180,\r\n      barWidth: 2,\r\n      waveAmplitude: 100,\r\n      radius: 80,\r\n      audioData,\r\n      strokeLinecap: \"round\" as const,\r\n      barMinHeight: 2,\r\n      transitionDuration: \"0.1s\",\r\n      transitionTimingFunction: \"ease-in-out\",\r\n      rotationOffset: 45,\r\n      barColor: \"var(--foreground)\",\r\n      growOutwardsOnly: true,\r\n    }),\r\n    [audioData]\r\n  );\r\n\r\n  // Calculate duration in frames for the player for better readability\r\n  const playerDurationInFrames = audioData\r\n    ? Math.floor(audioData.durationInSeconds * 30)\r\n    : 300;\r\n\r\n  return (\r\n    <div className=\"aspect-video h-[180px] sm:h-[350px] md:h-[400px]\">\r\n      <Player\r\n        component={AudioCircularWaveformComposition} // Use the new component\r\n        inputProps={{ circularWaveformProps, mediaSrc: MEDIA_SRC }} // Pass props directly\r\n        durationInFrames={playerDurationInFrames} // e.g., 10 seconds at 30fps\r\n        compositionWidth={640}\r\n        compositionHeight={360} // 16:9 aspect ratio\r\n        fps={30}\r\n        style={{\r\n          width: \"100%\",\r\n          height: \"100%\",\r\n          backgroundColor: \"transparent\",\r\n        }}\r\n        controls // Show player controls\r\n        loop\r\n      />\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:page",
      "target": "app/main.tsx"
    },
    {
      "path": "components/circular-waveform.tsx",
      "content": "\"use client\";\n\nimport React from \"react\";\nimport {\n  MediaUtilsAudioData,\n  visualizeAudioWaveform,\n} from \"@remotion/media-utils\";\nimport { random, useCurrentFrame, useVideoConfig } from \"remotion\";\n\ninterface CircularWaveformProps {\n  audioData?: MediaUtilsAudioData | null;\n  barCount?: number;\n  barWidth?: number;\n  barColor?: string;\n  waveAmplitude?: number;\n  radius?: number;\n  centerOffset?: { x?: number; y?: number };\n  containerStyle?: React.CSSProperties;\n  barStyle?: React.CSSProperties;\n  height?: string | number;\n  width?: string | number;\n  barMinHeight?: number;\n  strokeLinecap?: \"butt\" | \"round\" | \"square\";\n  transitionDuration?: string;\n  transitionTimingFunction?: string;\n  rotationOffset?: number;\n  growOutwardsOnly?: boolean;\n}\n\nexport default function CircularWaveform({\n  audioData,\n  barCount = 60,\n  barWidth = 5,\n  barColor = \"var(--foreground)\",\n  waveAmplitude = 50,\n  radius = 100,\n  centerOffset = { x: 0, y: 0 },\n  containerStyle,\n  barStyle,\n  height: propHeight,\n  width: propWidth,\n  barMinHeight = 5,\n  strokeLinecap = \"butt\",\n  transitionDuration = \"0.05s\",\n  transitionTimingFunction = \"ease-out\",\n  rotationOffset = 0,\n  growOutwardsOnly = false,\n}: CircularWaveformProps) {\n  const frame = useCurrentFrame();\n  const { width: videoWidth, height: videoHeight, fps } = useVideoConfig();\n\n  const finalWidth = propWidth ?? videoWidth;\n  const finalHeight = propHeight ?? videoHeight;\n\n  const centerX =\n    (typeof finalWidth === \"number\"\n      ? finalWidth / 2\n      : parseFloat(String(finalWidth).replace(\"px\", \"\")) / 2) +\n    (centerOffset.x ?? 0);\n  const centerY =\n    (typeof finalHeight === \"number\"\n      ? finalHeight / 2\n      : parseFloat(String(finalHeight).replace(\"px\", \"\")) / 2) +\n    (centerOffset.y ?? 0);\n\n  const waveformSamples = audioData\n    ? visualizeAudioWaveform({\n        fps,\n        frame,\n        audioData,\n        numberOfSamples: barCount,\n        windowInSeconds: 1 / fps,\n      })\n    : Array(barCount)\n        .fill(0)\n        .map((_, i) => {\n          const seed = i * 1000;\n          return (\n            Math.max(\n              0.1,\n              Math.abs(Math.sin(frame / 10 + i / (barCount / (2 * Math.PI)))) +\n                random(seed) * 0.3\n            ) *\n              0.5 +\n            0.25\n          );\n        });\n\n  const bars = waveformSamples.map((sample, i) => {\n    const angleRad =\n      (i / barCount) * 2 * Math.PI + (rotationOffset * Math.PI) / 180;\n    const dynamicHeight = Math.max(barMinHeight, sample * waveAmplitude);\n\n    let startRadius: number;\n    let endRadius: number;\n\n    if (growOutwardsOnly) {\n      startRadius = radius;\n      endRadius = radius + dynamicHeight;\n    } else {\n      startRadius = radius - dynamicHeight / 2;\n      endRadius = radius + dynamicHeight / 2;\n    }\n\n    if (startRadius < 0) {\n      endRadius += Math.abs(startRadius);\n      startRadius = 0;\n    }\n\n    const maxAllowedRadius = Math.min(centerX, centerY);\n    if (endRadius > maxAllowedRadius) {\n      endRadius = maxAllowedRadius;\n    }\n    if (startRadius > endRadius) {\n      startRadius = endRadius - barMinHeight > 0 ? endRadius - barMinHeight : 0;\n    }\n\n    const finalX1 = centerX + startRadius * Math.cos(angleRad);\n    const finalY1 = centerY + startRadius * Math.sin(angleRad);\n    const finalX2 = centerX + endRadius * Math.cos(angleRad);\n    const finalY2 = centerY + endRadius * Math.sin(angleRad);\n\n    return {\n      x1: finalX1,\n      y1: finalY1,\n      x2: finalX2,\n      y2: finalY2,\n      height: endRadius - startRadius,\n    };\n  });\n\n  return (\n    <div\n      style={{\n        width: finalWidth,\n        height: finalHeight,\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        overflow: \"hidden\",\n        backgroundColor: \"transparent\",\n        position: \"relative\",\n        ...containerStyle,\n      }}\n    >\n      <svg width=\"100%\" height=\"100%\" style={{ overflow: \"visible\" }}>\n        {bars.map((bar, i) => (\n          <line\n            key={i}\n            x1={bar.x1}\n            y1={bar.y1}\n            x2={bar.x2}\n            y2={bar.y2}\n            stroke={barColor}\n            strokeWidth={barWidth}\n            strokeLinecap={strokeLinecap}\n            style={{\n              transitionProperty: \"all\",\n              transitionDuration: transitionDuration,\n              transitionTimingFunction: transitionTimingFunction,\n              ...barStyle,\n            }}\n          />\n        ))}\n      </svg>\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": ""
    }
  ],
  "meta": {
    "iframeHeight": "600px",
    "container": "w-full bg-surface min-h-svh flex px-6 py-12 items-center md:pt-20 justify-center min-w-0 xl:py-24",
    "mobile": "component"
  }
}