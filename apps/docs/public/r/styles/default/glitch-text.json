{
  "name": "glitch-text",
  "type": "registry:component",
  "dependencies": [
    "remotion"
  ],
  "files": [
    {
      "path": "components/glitch-text.tsx",
      "content": "\"use client\";\r\n\r\nimport { useCurrentFrame } from \"remotion\";\r\n\r\ninterface GlitchTextProps {\r\n  text?: string;\r\n  textColor?: string;\r\n  glitchTextColor1?: string;\r\n  glitchTextColor2?: string;\r\n  glitchTextColor3?: string;\r\n  fontSize?: string;\r\n  fontFamily?: string;\r\n  fontWeight?: string;\r\n  glitchStrength?: number;\r\n  glitchSpeed?: number;\r\n  sporadicGlitchChance?: number;\r\n}\r\n\r\nexport default function GlitchText({\r\n  text = \"GLITCH\",\r\n  textColor = \"white\", // Using new CSS variable\r\n  glitchTextColor1 = \"var(--glitch-color-1)\", // Using new CSS variable\r\n  glitchTextColor2 = \"var(--glitch-color-2)\", // Using new CSS variable\r\n  fontSize = \"5rem\",\r\n  fontFamily = \"monospace\",\r\n  fontWeight = \"bold\",\r\n  glitchStrength = 10,\r\n  glitchSpeed = 5,\r\n  sporadicGlitchChance,\r\n}: GlitchTextProps) {\r\n  const frame = useCurrentFrame();\r\n\r\n  let currentGlitchIntensity = 0;\r\n  let currentRgbOffset = 0;\r\n\r\n  if (sporadicGlitchChance !== undefined && sporadicGlitchChance > 0) {\r\n    // Sporadic glitch logic\r\n    if (Math.random() < sporadicGlitchChance) {\r\n      // Glitch happens based on chance\r\n      // Use glitchSpeed to determine how often a *new* random glitch can occur,\r\n      // rather than how fast a continuous sine wave moves.\r\n      // For example, a higher glitchSpeed could mean we only pick new random values less often.\r\n      // This interpretation might need refinement based on desired effect.\r\n      // For now, let's make it so that a glitch, when it occurs, has a random intensity.\r\n      if (\r\n        frame % Math.max(1, Math.floor(glitchSpeed)) === 0 ||\r\n        glitchSpeed < 1\r\n      ) {\r\n        currentGlitchIntensity = (Math.random() - 0.5) * 2 * glitchStrength; // Random value between -glitchStrength and +glitchStrength\r\n        currentRgbOffset = (Math.random() - 0.5) * 2 * (glitchStrength / 1.5); // Slightly less offset for RGB\r\n      }\r\n    }\r\n    // Else, no glitch on this frame for sporadic mode\r\n  } else {\r\n    // Original continuous glitch logic\r\n    currentGlitchIntensity = Math.sin(frame / glitchSpeed) * glitchStrength;\r\n    currentRgbOffset =\r\n      Math.sin(frame / (glitchSpeed / 2)) * (glitchStrength / 2);\r\n  }\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        position: \"absolute\",\r\n        top: \"50%\",\r\n        left: \"50%\",\r\n        transform: \"translate(-50%, -50%)\",\r\n        fontSize,\r\n        fontWeight,\r\n        fontFamily,\r\n      }}\r\n    >\r\n      <div\r\n        style={{\r\n          position: \"absolute\",\r\n          color: glitchTextColor1,\r\n          transform: `translate(${currentRgbOffset}px, ${currentGlitchIntensity}px)`,\r\n          mixBlendMode: \"screen\", // Consider if 'screen' is desired for B&W\r\n          opacity: 0.6, // Added opacity for better layering\r\n        }}\r\n      >\r\n        {text}\r\n      </div>\r\n      <div\r\n        style={{\r\n          position: \"absolute\",\r\n          color: glitchTextColor2,\r\n          transform: `translate(${-currentRgbOffset}px, ${-currentGlitchIntensity}px)`,\r\n          mixBlendMode: \"screen\", // Consider if 'screen' is desired for B&W\r\n          opacity: 0.6, // Added opacity for better layering\r\n        }}\r\n      >\r\n        {text}\r\n      </div>\r\n      <div style={{ color: textColor, opacity: 0.8 }}>{text}</div>\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": ""
    }
  ]
}