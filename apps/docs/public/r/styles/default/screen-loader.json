{
  "name": "screen-loader",
  "type": "registry:component",
  "dependencies": [
    "remotion"
  ],
  "files": [
    {
      "path": "components/screen-loader.tsx",
      "content": "\"use client\";\n\nimport React from \"react\";\nimport { Easing, interpolate, useCurrentFrame } from \"remotion\";\n\nexport interface ScreenLoaderProps {\n  // Loader appearance\n  loaderSize?: number; // Size of the moving square\n  loaderColor?: string; // Color of the moving square\n\n  // Container dimensions (where the loader will travel)\n  // These props will be used to calculate the path.\n  // The parent component rendering this loader should have these dimensions\n  // and typically 'position: relative'.\n  containerWidth: number;\n  containerHeight: number;\n\n  // Animation behavior\n  durationInFrames?: number; // Duration for one full loop\n  loop?: boolean; // Whether the animation should loop\n  variant?: \"single\" | \"double\"; // Added variant prop\n}\n\nexport default function ScreenLoader({\n  loaderSize = 20,\n  loaderColor = \"blue\",\n  containerWidth,\n  containerHeight,\n  durationInFrames = 120,\n  loop = true,\n  variant = \"single\", // Default to single\n}: ScreenLoaderProps) {\n  const frame = useCurrentFrame();\n\n  const s2 = loaderSize / 2;\n\n  // Define effective corner points for the centerline, inset by s2\n  const x0_eff = s2;\n  const y0_eff = s2;\n  const x1_eff = containerWidth - s2;\n  const y1_eff = containerHeight - s2;\n\n  // Path lengths for travel, based on dimensions available for centerline movement\n  const L1 = containerWidth - loaderSize;\n  const L2 = containerHeight - loaderSize;\n  const L3 = containerWidth - loaderSize;\n  const L4 = containerHeight - loaderSize;\n\n  // Prevent negative lengths if loaderSize is too large\n  const L1_safe = Math.max(0, L1);\n  const L2_safe = Math.max(0, L2);\n  const L3_safe = Math.max(0, L3);\n  const L4_safe = Math.max(0, L4);\n  const totalPerimeterPathLength = L1_safe + L2_safe + L3_safe + L4_safe;\n\n  const progress = React.useMemo(() => {\n    const currentFrameInCycle = loop\n      ? frame % durationInFrames\n      : Math.min(frame, durationInFrames - 1);\n    // Avoid division by zero if path is zero length\n    if (totalPerimeterPathLength === 0 && variant === \"single\") return 0;\n    // For double variant, pathSegmentLength could also be 0, handled in calculatePolylinePoints\n    return interpolate(currentFrameInCycle, [0, durationInFrames - 1], [0, 1], {\n      extrapolateRight: \"clamp\",\n      easing: Easing.linear,\n    });\n  }, [frame, durationInFrames, loop, totalPerimeterPathLength, variant]);\n\n  if (containerWidth < loaderSize || containerHeight < loaderSize) {\n    console.warn(\n      \"ScreenLoader: containerWidth or containerHeight is smaller than loaderSize. Loader might not render correctly or be visible.\"\n    );\n  }\n\n  const calculatePolylinePoints = (\n    currentProg: number,\n    startCorner:\n      | \"topLeft\"\n      | \"bottomRight\"\n      | \"topRight\"\n      | \"bottomLeft\"\n      | \"topLeftSingle\"\n  ): string => {\n    const pathSegmentLength = L1_safe + L2_safe;\n    const currentDistance =\n      pathSegmentLength > 0 ? currentProg * pathSegmentLength : 0;\n    const totalDistSingle =\n      totalPerimeterPathLength > 0 ? currentProg * totalPerimeterPathLength : 0;\n\n    const points: { x: number; y: number }[] = [];\n\n    if (startCorner === \"topLeft\") {\n      const P0 = { x: x0_eff, y: y0_eff };\n      const P1 = { x: x1_eff, y: y0_eff };\n      const P2 = { x: x1_eff, y: y1_eff };\n\n      points.push(P0);\n      if (currentDistance <= L1_safe) {\n        points.push({ x: x0_eff + currentDistance, y: y0_eff });\n      } else if (currentDistance <= L1_safe + L2_safe) {\n        points.push(P1);\n        points.push({ x: P1.x, y: y0_eff + (currentDistance - L1_safe) });\n      } else {\n        points.push(P1);\n        points.push(P2);\n      }\n    } else if (startCorner === \"bottomRight\") {\n      const P0 = { x: x1_eff, y: y1_eff };\n      const P1 = { x: x0_eff, y: y1_eff };\n      const P2 = { x: x0_eff, y: y0_eff };\n\n      points.push(P0);\n      if (currentDistance <= L3_safe) {\n        points.push({ x: x1_eff - currentDistance, y: P0.y });\n      } else if (currentDistance <= L3_safe + L4_safe) {\n        points.push(P1);\n        points.push({ x: P1.x, y: y1_eff - (currentDistance - L3_safe) });\n      } else {\n        points.push(P1);\n        points.push(P2);\n      }\n    } else if (startCorner === \"topLeftSingle\") {\n      const P0_s = { x: x0_eff, y: y0_eff };\n      const P1_s = { x: x1_eff, y: y0_eff };\n      const P2_s = { x: x1_eff, y: y1_eff };\n      const P3_s = { x: x0_eff, y: y1_eff };\n\n      points.push(P0_s);\n      if (totalDistSingle <= L1_safe) {\n        points.push({ x: x0_eff + totalDistSingle, y: y0_eff });\n      } else if (totalDistSingle <= L1_safe + L2_safe) {\n        points.push(P1_s);\n        points.push({ x: P1_s.x, y: y0_eff + (totalDistSingle - L1_safe) });\n      } else if (totalDistSingle <= L1_safe + L2_safe + L3_safe) {\n        points.push(P1_s);\n        points.push(P2_s);\n        points.push({\n          x: x1_eff - (totalDistSingle - (L1_safe + L2_safe)),\n          y: P2_s.y,\n        });\n      } else if (totalDistSingle <= L1_safe + L2_safe + L3_safe + L4_safe) {\n        points.push(P1_s);\n        points.push(P2_s);\n        points.push(P3_s);\n        points.push({\n          x: P3_s.x,\n          y: y1_eff - (totalDistSingle - (L1_safe + L2_safe + L3_safe)),\n        });\n      } else if (totalPerimeterPathLength > 0) {\n        points.push(P1_s, P2_s, P3_s, P0_s);\n      }\n      // If path length is zero, P0_s is already pushed. If it needs to be a dot, add P0_s again.\n      if (totalPerimeterPathLength === 0 && points.length === 1) {\n        points.push(P0_s);\n      }\n    }\n\n    // Ensure a drawable line if only one point and path is possible, or a dot if path is zero.\n    if (points.length === 1) {\n      if (\n        (startCorner === \"topLeftSingle\" && totalPerimeterPathLength > 0) ||\n        (variant === \"double\" && pathSegmentLength > 0)\n      ) {\n        const lastPoint = points[0];\n        points.push({ x: lastPoint.x + 0.001, y: lastPoint.y + 0.001 }); // Tiny segment\n      } else {\n        // Path length is 0, make it a dot by repeating the point\n        points.push(points[0]);\n      }\n    } else if (points.length === 0) {\n      // Should only happen if containerSize < loaderSize for all paths\n      const fallbackX = containerWidth / 2;\n      const fallbackY = containerHeight / 2;\n      points.push(\n        { x: fallbackX, y: fallbackY },\n        { x: fallbackX, y: fallbackY }\n      );\n    }\n\n    return points.map((p) => `${p.x},${p.y}`).join(\" \");\n  };\n\n  const polylinePointsString1 =\n    variant === \"double\"\n      ? calculatePolylinePoints(progress, \"topLeft\")\n      : calculatePolylinePoints(progress, \"topLeftSingle\");\n\n  const polylinePointsString2 =\n    variant === \"double\"\n      ? calculatePolylinePoints(progress, \"bottomRight\")\n      : \"\";\n\n  return (\n    <svg width={containerWidth} height={containerHeight}>\n      <polyline\n        points={polylinePointsString1}\n        fill=\"none\"\n        stroke={loaderColor}\n        strokeWidth={loaderSize}\n        strokeLinecap=\"square\"\n        strokeLinejoin=\"miter\"\n        shape-rendering=\"crispEdges\"\n      />\n      {variant === \"double\" && polylinePointsString2 && (\n        <polyline\n          points={polylinePointsString2}\n          fill=\"none\"\n          stroke={loaderColor}\n          strokeWidth={loaderSize}\n          strokeLinecap=\"square\"\n          strokeLinejoin=\"miter\"\n          shape-rendering=\"crispEdges\"\n        />\n      )}\n    </svg>\n  );\n}\n",
      "type": "registry:component",
      "target": ""
    }
  ]
}