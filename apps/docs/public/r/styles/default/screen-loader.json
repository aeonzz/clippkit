{
  "name": "screen-loader",
  "type": "registry:component",
  "dependencies": [
    "remotion"
  ],
  "files": [
    {
      "path": "components/screen-loader.tsx",
      "content": "\"use client\";\r\n\r\nimport React from \"react\";\r\nimport { Easing, interpolate, useCurrentFrame } from \"remotion\";\r\n\r\nexport interface ScreenLoaderProps {\r\n  // Loader appearance\r\n  loaderSize?: number; // Size of the moving square\r\n  loaderColor?: string; // Color of the moving square\r\n\r\n  // Container dimensions (where the loader will travel)\r\n  // These props will be used to calculate the path.\r\n  // The parent component rendering this loader should have these dimensions\r\n  // and typically 'position: relative'.\r\n  containerWidth: number;\r\n  containerHeight: number;\r\n\r\n  // Animation behavior\r\n  durationInFrames?: number; // Duration for one full loop\r\n  loop?: boolean; // Whether the animation should loop\r\n  variant?: \"single\" | \"double\"; // Added variant prop\r\n}\r\n\r\nexport default function ScreenLoader({\r\n  loaderSize = 20,\r\n  loaderColor = \"blue\",\r\n  containerWidth,\r\n  containerHeight,\r\n  durationInFrames = 120,\r\n  loop = true,\r\n  variant = \"single\", // Default to single\r\n}: ScreenLoaderProps) {\r\n  const frame = useCurrentFrame();\r\n\r\n  const s2 = loaderSize / 2;\r\n\r\n  // Define effective corner points for the centerline, inset by s2\r\n  const x0_eff = s2;\r\n  const y0_eff = s2;\r\n  const x1_eff = containerWidth - s2;\r\n  const y1_eff = containerHeight - s2;\r\n\r\n  // Path lengths for travel, based on dimensions available for centerline movement\r\n  const L1 = containerWidth - loaderSize;\r\n  const L2 = containerHeight - loaderSize;\r\n  const L3 = containerWidth - loaderSize;\r\n  const L4 = containerHeight - loaderSize;\r\n\r\n  // Prevent negative lengths if loaderSize is too large\r\n  const L1_safe = Math.max(0, L1);\r\n  const L2_safe = Math.max(0, L2);\r\n  const L3_safe = Math.max(0, L3);\r\n  const L4_safe = Math.max(0, L4);\r\n  const totalPerimeterPathLength = L1_safe + L2_safe + L3_safe + L4_safe;\r\n\r\n  const progress = React.useMemo(() => {\r\n    const currentFrameInCycle = loop\r\n      ? frame % durationInFrames\r\n      : Math.min(frame, durationInFrames - 1);\r\n    // Avoid division by zero if path is zero length\r\n    if (totalPerimeterPathLength === 0 && variant === \"single\") return 0;\r\n    // For double variant, pathSegmentLength could also be 0, handled in calculatePolylinePoints\r\n    return interpolate(currentFrameInCycle, [0, durationInFrames - 1], [0, 1], {\r\n      extrapolateRight: \"clamp\",\r\n      easing: Easing.linear,\r\n    });\r\n  }, [frame, durationInFrames, loop, totalPerimeterPathLength, variant]);\r\n\r\n  if (containerWidth < loaderSize || containerHeight < loaderSize) {\r\n    console.warn(\r\n      \"ScreenLoader: containerWidth or containerHeight is smaller than loaderSize. Loader might not render correctly or be visible.\"\r\n    );\r\n  }\r\n\r\n  const calculatePolylinePoints = (\r\n    currentProg: number,\r\n    startCorner:\r\n      | \"topLeft\"\r\n      | \"bottomRight\"\r\n      | \"topRight\"\r\n      | \"bottomLeft\"\r\n      | \"topLeftSingle\"\r\n  ): string => {\r\n    const pathSegmentLength = L1_safe + L2_safe;\r\n    const currentDistance =\r\n      pathSegmentLength > 0 ? currentProg * pathSegmentLength : 0;\r\n    const totalDistSingle =\r\n      totalPerimeterPathLength > 0 ? currentProg * totalPerimeterPathLength : 0;\r\n\r\n    const points: { x: number; y: number }[] = [];\r\n\r\n    if (startCorner === \"topLeft\") {\r\n      const P0 = { x: x0_eff, y: y0_eff };\r\n      const P1 = { x: x1_eff, y: y0_eff };\r\n      const P2 = { x: x1_eff, y: y1_eff };\r\n\r\n      points.push(P0);\r\n      if (currentDistance <= L1_safe) {\r\n        points.push({ x: x0_eff + currentDistance, y: y0_eff });\r\n      } else if (currentDistance <= L1_safe + L2_safe) {\r\n        points.push(P1);\r\n        points.push({ x: P1.x, y: y0_eff + (currentDistance - L1_safe) });\r\n      } else {\r\n        points.push(P1);\r\n        points.push(P2);\r\n      }\r\n    } else if (startCorner === \"bottomRight\") {\r\n      const P0 = { x: x1_eff, y: y1_eff };\r\n      const P1 = { x: x0_eff, y: y1_eff };\r\n      const P2 = { x: x0_eff, y: y0_eff };\r\n\r\n      points.push(P0);\r\n      if (currentDistance <= L3_safe) {\r\n        points.push({ x: x1_eff - currentDistance, y: P0.y });\r\n      } else if (currentDistance <= L3_safe + L4_safe) {\r\n        points.push(P1);\r\n        points.push({ x: P1.x, y: y1_eff - (currentDistance - L3_safe) });\r\n      } else {\r\n        points.push(P1);\r\n        points.push(P2);\r\n      }\r\n    } else if (startCorner === \"topLeftSingle\") {\r\n      const P0_s = { x: x0_eff, y: y0_eff };\r\n      const P1_s = { x: x1_eff, y: y0_eff };\r\n      const P2_s = { x: x1_eff, y: y1_eff };\r\n      const P3_s = { x: x0_eff, y: y1_eff };\r\n\r\n      points.push(P0_s);\r\n      if (totalDistSingle <= L1_safe) {\r\n        points.push({ x: x0_eff + totalDistSingle, y: y0_eff });\r\n      } else if (totalDistSingle <= L1_safe + L2_safe) {\r\n        points.push(P1_s);\r\n        points.push({ x: P1_s.x, y: y0_eff + (totalDistSingle - L1_safe) });\r\n      } else if (totalDistSingle <= L1_safe + L2_safe + L3_safe) {\r\n        points.push(P1_s);\r\n        points.push(P2_s);\r\n        points.push({\r\n          x: x1_eff - (totalDistSingle - (L1_safe + L2_safe)),\r\n          y: P2_s.y,\r\n        });\r\n      } else if (totalDistSingle <= L1_safe + L2_safe + L3_safe + L4_safe) {\r\n        points.push(P1_s);\r\n        points.push(P2_s);\r\n        points.push(P3_s);\r\n        points.push({\r\n          x: P3_s.x,\r\n          y: y1_eff - (totalDistSingle - (L1_safe + L2_safe + L3_safe)),\r\n        });\r\n      } else if (totalPerimeterPathLength > 0) {\r\n        points.push(P1_s, P2_s, P3_s, P0_s);\r\n      }\r\n      // If path length is zero, P0_s is already pushed. If it needs to be a dot, add P0_s again.\r\n      if (totalPerimeterPathLength === 0 && points.length === 1) {\r\n        points.push(P0_s);\r\n      }\r\n    }\r\n\r\n    // Ensure a drawable line if only one point and path is possible, or a dot if path is zero.\r\n    if (points.length === 1) {\r\n      if (\r\n        (startCorner === \"topLeftSingle\" && totalPerimeterPathLength > 0) ||\r\n        (variant === \"double\" && pathSegmentLength > 0)\r\n      ) {\r\n        const lastPoint = points[0];\r\n        points.push({ x: lastPoint.x + 0.001, y: lastPoint.y + 0.001 }); // Tiny segment\r\n      } else {\r\n        // Path length is 0, make it a dot by repeating the point\r\n        points.push(points[0]);\r\n      }\r\n    } else if (points.length === 0) {\r\n      // Should only happen if containerSize < loaderSize for all paths\r\n      const fallbackX = containerWidth / 2;\r\n      const fallbackY = containerHeight / 2;\r\n      points.push(\r\n        { x: fallbackX, y: fallbackY },\r\n        { x: fallbackX, y: fallbackY }\r\n      );\r\n    }\r\n\r\n    return points.map((p) => `${p.x},${p.y}`).join(\" \");\r\n  };\r\n\r\n  const polylinePointsString1 =\r\n    variant === \"double\"\r\n      ? calculatePolylinePoints(progress, \"topLeft\")\r\n      : calculatePolylinePoints(progress, \"topLeftSingle\");\r\n\r\n  const polylinePointsString2 =\r\n    variant === \"double\"\r\n      ? calculatePolylinePoints(progress, \"bottomRight\")\r\n      : \"\";\r\n\r\n  return (\r\n    <svg width={containerWidth} height={containerHeight}>\r\n      <polyline\r\n        points={polylinePointsString1}\r\n        fill=\"none\"\r\n        stroke={loaderColor}\r\n        strokeWidth={loaderSize}\r\n        strokeLinecap=\"square\"\r\n        strokeLinejoin=\"miter\"\r\n        shape-rendering=\"crispEdges\"\r\n      />\r\n      {variant === \"double\" && polylinePointsString2 && (\r\n        <polyline\r\n          points={polylinePointsString2}\r\n          fill=\"none\"\r\n          stroke={loaderColor}\r\n          strokeWidth={loaderSize}\r\n          strokeLinecap=\"square\"\r\n          strokeLinejoin=\"miter\"\r\n          shape-rendering=\"crispEdges\"\r\n        />\r\n      )}\r\n    </svg>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": ""
    }
  ]
}